package cz.janburda03.numintegrator.app;

import cz.janburda03.numintegrator.parsing.input.IntegrationInput;
import cz.janburda03.numintegrator.parsing.input.VariableRange;
import cz.janburda03.numintegrator.sampling.HaltonSampler;
import cz.janburda03.numintegrator.sampling.RandomSampler;
import cz.janburda03.numintegrator.sampling.Sampler;
import cz.janburda03.numintegrator.sampling.GridSampler;

import java.util.Map;

/**
 * Numerical integrator using sampling-based methods.
 *
 * <p>Provides static methods to approximate multidimensional definite integrals
 * by evaluating the integrand at points generated by a {@link Sampler}.</p>
 *
 * <p>Supported sampling strategies include:</p>
 * <ul>
 *     <li>{@link GridSampler} – uniform grid sampling</li>
 *     <li>{@link RandomSampler} – independent random sampling</li>
 *     <li>{@link HaltonSampler} – low-discrepancy Halton sequences</li>
 * </ul>
 */
public class Integrator {

    private Integrator() {}

    /**
     * Approximates a multidimensional definite integral using the specified sampling strategy.
     *
     * <p>The integral is computed as the average of the integrand evaluated at sampled points,
     * multiplied by the total volume of the integration domain.</p>
     *
     * @param input integration configuration (function, variables, sampling type, sample count)
     * @return approximate value of the integral
     */
    public static double integrate(IntegrationInput input) {
        // Create sampler based on requested strategy
        Sampler sampler = switch (input.getSamplingType()) {
            case GRID -> new GridSampler(input.getSampleCount(), input.getVariablesRanges());
            case RANDOM -> new RandomSampler(input.getSampleCount(), input.getVariablesRanges());
            case HALTON -> new HaltonSampler(input.getSampleCount(), input.getVariablesRanges());
        };

        // Sum integrand values at all sampled points
        double sum = 0.0;
        for (Map<String, Double> sample : sampler) {
            sum += input.getExpression().evaluate(sample);
        }

        // Average and scale by total domain volume
        double average = sum / input.getSampleCount();
        return average * computeVolume(input.getVariablesRanges());
    }

    /**
     * Computes the total volume of the integration domain.
     *
     * @param ranges variable ranges defining the integration domain
     * @return total volume
     */
    private static double computeVolume(Map<String, VariableRange> ranges) {
        double volume = 1.0;
        for (VariableRange r : ranges.values()) {
            volume *= (r.getMax() - r.getMin());
        }
        return volume;
    }
}


